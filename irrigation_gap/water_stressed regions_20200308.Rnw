\documentclass{article}

\begin{document}



<<>>=
library(dplyr)
library(ggplot2)
library(rworldmap)
library(ggalt)
library(rgdal)
library(raster)
library(ncdf4)
library(lattice)
library(boot)
library(reshape2)
library(rasterVis)
library(ggthemes)
library(tidyr)
@


\section{Overview}
Data
Mek/Hoek2016 at least 1 month/yr
AND
IPPC definition of a semi-arid region receives less than or equal to 10-in or 250 mm per year
AND
HDI low and medium categories (under .70)

Steps
Look at years from 1996-2005 (overlap with above) and if median monthly is > than 1 or < 250 mm and > 50 mm then keep.
Mask out non-LMIC

\section{Data}

Mek/Hoek2016 (blue water scarcity, blue data hereafter)

<<>>=
b <- raster('data/WS_blue_monthly_rasters/WSbl_monthly_30m/no_of_months/w001001.adf')
@

GPCC (Global Precipitation Climate Center) Total Full V2018 (0.5x0.5) (aridity hereafter)
https://www.esrl.noaa.gov/psd/data/gridded/data.gpcc.html

Set to the same years as Mek/Hoek2016 (1996-2005).
<<>>=
g <- brick('data/precipitation/precip.mon.total.v2018.nc')
g <- g[[which(getZ(g) >= as.Date('1996-01-01') & getZ(g) <= as.Date('2005-12-31'))]]
@

Take median rainfall values.

<<>>=
g <- calc(g, median)
g <- rotate(g)
@

Get the HDI data for the most recent year (2017).
"Data descriptor: The subnational human development database"

<<>>=
# TODO: testing new hdi layer from https://www.nature.com/articles/sdata20184 in h2
h1 <- raster('data/hdi/hdi_2017.tif')
# h2 <- raster('data/hdi2/HDI_1990_2015_v2.nc', 
#              band = 26)
# h3 <- raster('data/hdi2/GDP_per_capita_PPP_1990_2015_v2.nc', 
#              band = 26)
h <- h1
names(h) <- names(h1)
@

Get the World Bank 2019 LMIC classifications. Subset to the LMICs.

<<>>=
lmic <- read.csv('data/lmic/country_regions_economies.csv')
@

Farm size 

<<>>=
# fs <- raster('data/farm_size/farmSize_lesiv_knn_ag_100.tif')
fs <- list.files(path = 'data/farm_size/', 
                 pattern = 'tif$', 
                 full.names = T)
fs <- stack(fs)
fs <- brick(fs)

getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

fs <- calc(fs, getmode)
@

Irrigation from Salmon et al. 2015. Where class 1 is rainfed, class 2 is irrigated, and class 3 is paddy.
https://sgst.wr.usgs.gov/gfsad30/GRIPC/GRIPCmap/mosaic/
https://www.sciencedirect.com/science/article/pii/S0303243415000240

<<>>=
irr <- raster('data/irrigation/GRIPC/GRIPC_irri_area.tif')
irr_paddy <- raster('data/irrigation/GRIPC/gripc_paddy_area.tif')
irr_rain <- raster('data/irrigation/GRIPC/gripc_rainfed_area.tif')
@

We make a raster of the world country data from the rworldmap package.

<<makeCountriesRaster>>=
world  <- getMap(resolution = 'low')
lookup <- as.data.frame(cbind(as.character(
  world@data[,'ISO3']),
  world@data[,'ADMIN'],
  as.character(world@data[,'ADMIN'])))

raster.world <- raster(res = c(0.0833282, 0.0833282))
extent(raster.world) <- extent(world)
world.raster <- rasterize(as(world, 'SpatialPolygons'), 
                          raster.world,
                          field = world@data[, 'ADMIN'],
                          fun   = 'first')
world.rast <- writeRaster(world.raster, 
                          'data/precipitation/worldrast.tif', 
                          format    = 'GTiff', 
                          overwrite = TRUE)

world  <- raster('data/precipitation/worldrast.tif')
@

Plot all geospatial datasets.

<<>>=
# par(mfrow = c(2,3))
# plot(b)
# plot(g)
# plot(h)
# plot(irr)
# plot(irr_paddy)
# plot(irr_rain)
# plot(fs)
# plot(world)
@

\section{Preprocess data}

Need to match crs, extents, and center values across datasets.

Use blue as a base dataset and set all datatsets' projections and extents.

\subsubsection{Convert to Equal Area}

Here we set each dataset to have an equal area (Ekert IV) at a 8.4 km\textsuperscript{2} resolution.

<<>>=
rast.list.ngb <- list(fs, b, world)
rast.list.bil <- list(g, h, irr, irr_paddy, irr_rain)

resValue <- 8439
rast.list.ngb.eq <- lapply(rast.list.ngb, function(x)
  projectRaster(x,
                res    = c(resValue, resValue),
                crs    = '+proj=eck4 +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0',
                method = 'ngb',
                over   = T))
names(rast.list.ngb.eq[[1]]) <- 'fs'
names(rast.list.ngb.eq[[2]]) <- 'w001001'
names(rast.list.ngb.eq[[3]]) <- 'worldrast'

rast.list.bil.eq <- lapply(rast.list.bil, function(x)
  projectRaster(x, 
                res    = c(resValue, resValue),
                crs    = '+proj=eck4 +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0',
                method = 'bilinear',
                over   = T))
names(rast.list.bil.eq[[1]]) <- 'layer'
names(rast.list.bil.eq[[2]]) <- 'hdi_2017'
names(rast.list.bil.eq[[3]]) <- 'GRIPC_irri_area'
names(rast.list.bil.eq[[4]]) <- 'gripc_paddy_area '
names(rast.list.bil.eq[[5]]) <- 'gripc_rainfed_area'

rast.list <- c(rast.list.ngb.eq, rast.list.bil.eq)  # Combine data
@

\subsubsection{Set Extents}

Next, we need to make sure that all the rasters have the same spatial extents.

<<>>=
ex1 <- extent(rast.list[[1]])

# Extend
rast.list.ex <- lapply(rast.list,    
                       function(x) extend(x, ex1))
# Crop
rast.list.c  <- lapply(rast.list.ex, 
                       function(x) crop(x, ex1))
# Force equal extent
rast.list.et <- lapply(rast.list.c,  
                       function(x) setExtent(x, ex1,
                                             keepres = TRUE))
@

\subsubsection{Create Stack and Dataframe}

Now that all the layers' resolution, crs, and spatial extent are equal, we can create a raster stack and proceed with the analysis.

<<rasterStack>>=
rast.all <- stack(rast.list.et)
@

Re-check all plots.

<<finalRasterprepPlot>>=
par(mfrow = c(3,4))
plot(rast.all)
@

Convert stack into a dataframe.

<<>>=
df <- raster::extract(rast.all, 1:ncell(rast.all), df = T)
@

\section{Final dataframe}

<<>>=
tmp <- df
@

Convert country ID to country name

<<>>=
require(rworldmap)
world  <- getMap(resolution = 'low')
lookup <- as.data.frame(
  cbind(
    as.character(world@data[,'ISO3']),
    world@data[,'ADMIN'],
    as.character(world@data[,'ADMIN'])))

matched     <- lookup[match(tmp$world, lookup$V2), ]
tmp$ISO3    <- matched[[1]]
tmp$country <- matched[[3]]
@

Add dummy variable for if country is a LMIC.

<<>>=
tmp <- merge(tmp, lmic, by.x = 'ISO3', by.y = 'Code', all.x = T)
@

Define smallholders: 
Rank farm size per country to identify if pixel represents smallest 40\% of farms in a country (one of the two intersection dimensions of small-scale farms for SDG 2.3)

<<>>=
# tmp$fs <- tmp$fs
tmp1 <- tmp %>%
  group_by(country) %>%
  # arrange(fs, .by_group = T) %>%
  # mutate(rank_fs = 
  #          cumsum(ifelse(is.na(fs), 0, fs)) + fs * 0,
  #        rel_fs = rank_fs / max(rank_fs, na.rm = T),
  #        rel_fs = ifelse(rel_fs > 0, rel_fs, NA),
  #        rel_fs = ifelse(is.finite(rel_fs), rel_fs, NA)) %>%
  # arrange(hdi_2017, .by_group = T) %>%
  # mutate(rank_hdi = 
  #          cumsum(ifelse(is.na(hdi_2017) | 
  #                          is.infinite(hdi_2017), 0, hdi_2017)) + 
  #                          hdi_2017 * 0,
  #        rel_hdi = rank_hdi / max(rank_hdi, na.rm = T),
  #        # rel_hdi = ifelse(rel_hdi > 0, rel_hdi, NA),
  #        rel_hdi = ifelse(is.finite(rel_hdi), rel_hdi, NA)) %>%
  mutate(hdi_2017 = ifelse(gripc_paddy_area + 
                           gripc_rainfed_area + 
                           GRIPC_irri_area > 0, hdi_2017, NA),
         fs_binary = ifelse(fs <= quantile(
                      fs, .4, na.rm = T, type = 8), 1,
                     ifelse(
                       fs >= quantile(fs, .4, na.rm = T, type = 8), 0, NA)),
         hdi_binary = ifelse(hdi_2017 <= quantile(
                        hdi_2017, .4, na.rm = T, type = 8), 1,
                      ifelse(hdi_2017 >= quantile(
                        hdi_2017, .4, na.rm = T, type = 8), 0, NA))) %>%
  ungroup()
@

Produce final definition of smallholders:
ID [water stressed (< 250 mm rainfall per year (note, that below, we subset is to 20.8333 = 250 / 12 months as is the dataset) OR > 1 month water stress per year) AND small farm (by 40\% definition) AND low HDI areas (<= .55) AND LMICs.

And produce one without rural subset for later mapping.

<<>>=
tmp1 <- tmp1 %>% 
  mutate(size = ifelse(fs_binary == 1 &
                       hdi_2017 <= .549,
                       # hdi_2017 <= .699,
                       'Small-scale',
                       ifelse(fs_binary == 0, 'Not small-scale', NA)),
         size = ifelse(Income.group %in% c('Low income',
                                           'Lower middle income'), 
                       size, NA))
@

Calculate global totals

<<>>=
tmp2 <- tmp1 %>%
      mutate(waterScarce = ifelse((w001001 >= 1) | (layer < 20.8333), 
                                  'Water Scarce', 'Not Water Scarce')) %>%
                           # ifelse((w001001 < 1) | (layer >= 20.8333), 
                                  # 'Not Water Scarce', NA))) %>%
      filter(!is.na(GRIPC_irri_area)) %>%
      mutate(tot = GRIPC_irri_area  + 
                   gripc_rainfed_area) %>%
                   # gripc_paddy_area) %>%
      group_by(waterScarce, size) %>%
      summarise(tot = sum(tot, na.rm = T),
                p_irr = sum(GRIPC_irri_area, na.rm = T) / tot, 
                # p_paddy = sum(gripc_paddy_area, na.rm = T) / tot,
                p_rain = sum(gripc_rainfed_area, na.rm = T) / tot) %>%
  na.omit() %>%
  ungroup() %>%
  group_by(size) %>%
  mutate(p_tot = tot / sum(tot)) %>%
  dplyr::select(waterScarce, size, p_irr, p_rain, tot)

tmp2$tot <- NULL
tmp2 <- melt(tmp2, id.vars = c('waterScarce', 'size'))
tmp2$variable <- factor(tmp2$variable, rev(c('p_irr', 'p_paddy', 'p_rain')),
                        labels = rev(c('Irrigated', 'Rice Paddy', 'Rainfed')))

ggplot(tmp2, aes(size, value, fill = variable)) +
  geom_bar(stat = 'identity') +
  coord_flip() +
  xlab('') +
  labs(fill = '') +
  scale_fill_manual(values = c('grey90', 'grey70', 'grey30')) +
  theme_void() +
  theme(legend.position = 'bottom',
        legend.justification = 'center',
        legend.text = element_text(size = 8),
        axis.title = element_text(size = 8),
        axis.text.y = element_text(hjust = 0),
        axis.text = element_text(size = 8),
        text = element_text(size = 8)) +
  ylab('\nPercent of agricultural land\n') +
  facet_wrap(~ waterScarce)

write.csv(tmp2, '../fulltext_analysis/input/water_stressed_fs_globalLevel_hdilow.csv')
@


Calculate countries with the largest area of water stressed agricultural land farmed by smallholders.

<<>>=
tmp3 <- tmp1 %>%
      filter(!is.na(GRIPC_irri_area) &
             !is.na(ISO3)) %>%
      mutate(tot = GRIPC_irri_area  + 
                   gripc_rainfed_area) %>%
                   # gripc_paddy_area) %>% 
      group_by(ISO3, size) %>%
      summarise(tot = sum(tot, na.rm = T),
                p_irr = sum(GRIPC_irri_area, na.rm = T) / tot, 
                # p_paddy = sum(gripc_paddy_area, na.rm = T) / tot,
                p_rain = sum(gripc_rainfed_area, na.rm = T) / tot) %>%
  na.omit() %>%
  mutate(p_irr = p_irr * 100) %>% 
  select(ISO3, size, p_irr) %>% 
  group_by(ISO3) %>% 
  spread(size, p_irr) %>% 
  mutate(`Not small-scale` = ifelse(
    is.na(`Not small-scale`), 0, `Not small-scale`),
         `Small-scale` = ifelse(
    is.na(`Small-scale`), 0, `Small-scale`),
         gap = `Not small-scale` - `Small-scale`) %>%
  ungroup() %>%
  arrange(desc(gap)) %>%
  mutate(ISO3 = factor(ISO3, ISO3),
         color = ifelse(gap < 0, 'green', 'red'))

write.csv(tmp3, '../fulltext_analysis/input/water_stressed_fs_countryLevel_hdiLow_irrig.csv')
@



Place global layer into a raster for plotting.

<<>>=
tmp_small_ws <- tmp1 %>% 
  mutate(rasterValue = ifelse(fs_binary == 1 &
                              # hdi_2017 <= .549 &
                              (w001001 >= 1) | (layer < 20.8333),
                              hdi_2017, NA))
         # rasterValue = ifelse(Income.group %in% c('Low income',
         #                                           'Lower middle income'), 
         #                      rasterValue, NA))
                              
                              


final_raster <- function(dat) {
  
  rast_final <- rast.all@layers[[1]]
  dat <- dat[order(dat$ID), ]
  final_vector <- as.vector(dat$rasterValue)
  rast_final <- setValues(rast_final, final_vector)
  
  return(rast_final)
}

r_v <- as.data.frame(final_raster(tmp_small_ws), xy = T) %>%
  filter(!is.na(fs)) %>%
  mutate(fs = ifelse(fs <= .549, 'Low HDI',
              ifelse(fs > .549 &
                     fs <= .699, 'Medium HDI',
              ifelse(fs > .699 &
                     fs <= .799, 'High HDI',
              ifelse(fs > .799, 'Very High HDI', NA)))),
         fs = factor(fs, c('Low HDI', 'Medium HDI', 
                           'High HDI', 'Very High HDI')))

r_w_lmic <- as.data.frame(final_raster(
  tmp_small_ws %>% 
    mutate(rasterValue = ifelse(!is.na(ISO3), 1, NA),
           rasterValue = ifelse(Income.group %in% c('Low income',
                                                   'Lower middle income'), 
                              rasterValue, NA))),
  xy = T) %>%
  filter(!is.na(fs))

r_w_hic <- as.data.frame(final_raster(
  tmp_small_ws %>% 
    mutate(rasterValue = ifelse(!is.na(ISO3), 1, NA),
           rasterValue = ifelse(!Income.group %in% c('Low income',
                                                   'Lower middle income'), 
                              rasterValue, NA))),
  xy = T) %>%
  filter(!is.na(fs))

library(ggthemr)
ggthemr('light')
tg <- theme_get()

ggplot() +
  geom_tile(aes(x, y,
                fill = 'Low and Middle Income Countries'),
            show.legend = T,
            data = r_w_lmic) + #%>% 
              # filter(y < 5e+06 & y > 3e+06 & x < 1e+07 & x > 9.5e+06)) +
  geom_tile(aes(x, y,
                fill = 'High and Upper Middle Income'),
            show.legend = T,
            data = r_w_hic) + # %>% 
              # filter(y < 5e+06 & y > 3e+06 & x < 1e+07 & x > 9.5e+06)) +
  geom_tile(aes(x, y,
                fill = fs),
            show.legend = T,
            data = r_v) + # %>% 
              # filter(y < 5e+06 & y > 3e+06 & x < 1e+07 & x > 9.5e+06)) +
  labs(fill = element_blank()) +
  coord_equal() +
  theme_map() +
  scale_fill_manual(
    element_blank(), 
    values = c('Very High HDI' = swatch()[1],
               'High HDI' = swatch()[2],
               'Medium HDI' = swatch()[3],
               'Low HDI'  = swatch()[5],
               'High and Upper Middle Income'  = 'grey90',
               'Low and Middle Income Countries' = 'grey80'), 
    breaks = c('Very High HDI', 
               'High HDI', 
               'Medium HDI', 
               'Low HDI',
               'High and Upper Middle Income',
               'Low and Middle Income Countries'))


ggsave('../fulltext_analysis/output/fig_highres_map.png')



# boot_function <- function(dat, i, x, ws = F) {
#   
#   dat_sub <- dat[i,]
# 
#   if (ws == F) {
#     
#     dat_sub <- dat_sub %>%
#       dplyr::select(GRIPC_irri_area, size, w001001, layer, Region) %>%
#       filter(size == x & (w001001 < 1 | layer >= 20.8333)) %>%
#       mutate(n_tot = (8.9 * 100 * length(!is.na(GRIPC_irri_area)))) %>%
#       summarise(p = sum(GRIPC_irri_area, na.rm = T) / max(n_tot))
#   
#   } else {
#     
#     dat_sub <- dat_sub %>%
#       dplyr::select(GRIPC_irri_area, size, w001001, layer, Region) %>%
#       filter(size == x & (w001001 >= 1 | layer < 20.8333)) %>%
#       mutate(n_tot = (8.9 * 100 * length(!is.na(GRIPC_irri_area)))) %>%
#       summarise(p = sum(GRIPC_irri_area, na.rm = T) / max(n_tot))
#   
#   } 
#   dat_sub$p
# }
# 
# n_boots <- 3
# tmp2 <- tmp1 %>% dplyr::select(size, GRIPC_irri_area, w001001, layer, Region)
# b_sm <- boot(tmp2, boot_function, x = 'small', ws = F, 
#              R = n_boots, parallel = 'multicore', ncpus = 3)
# b_sm_ws <- boot(tmp2, boot_function, x = 'small', ws = T, 
#                 R = n_boots, parallel = 'multicore', ncpus = 3)
# b_lg <- boot(tmp2, boot_function, x = 'large', ws = F, 
#              R = n_boots, parallel = 'multicore', ncpus = 3)
# b_lg_ws <- boot(tmp2, boot_function, x = 'large', ws = T, 
#                 R = n_boots, parallel = 'multicore', ncpus = 3)
# 
# labs <- c('small', 'small_ws', 'large', 'large_ws')
# bs <- list(b_sm, b_sm_ws, b_lg, b_lg_ws)
# 
# for (i in 1:4) {
#   
#   b_ci <- boot.ci(bs[[i]], type = 'norm')
#   b <- data.frame(
#     value = bs[[i]]$t0,
#     min = b_ci$normal[2],
#     max = b_ci$normal[3],
#     lab = labs[i]
#   )
#   
#   if (i == 1) {
#     out <- b
#   } else {
#     out <- rbind(out, b)
#   }
# }
@


<<>>=
# dd <- out %>%
#   mutate(labs = factor(labs, levels = c(
#       'small_ws', 'large_ws', 'small', 'large')),
#     ws = ifelse(labs %in% c('small_ws', 'large_ws'), 
#                 'In water scarce region', 'Not in water scarce region'))
# levels(dd$labs) <- c('Smallholders',
#                      'Non-smallholders',
#                      'Smallholders ',
#                      'Non-smallholders ')
# 
# p_scatter <- ggplot(dd, aes(labs, 100 * value, fill = ws)) +
#   geom_bar(stat = 'identity') +
#   geom_errorbar(aes(ymin = 100 * min, ymax = 100 * max), width = .0, color = 'black') +
#   coord_flip() +
#   xlab('') +
#   labs(fill = '') +
#   scale_fill_manual(values = c('grey30', 'grey70')) + # orange, blue
#   theme_void() +
#   theme(legend.position = 'bottom',
#         legend.justification = 'center',
#         legend.text = element_text(size = 8),
#         axis.title = element_text(size = 8),
#         axis.text.y = element_text(hjust = 0),
#         axis.text = element_text(size = 8),
#         text = element_text(size = 8)) +
#   ylab('\nPercent of agricultural land under irrigation\n')
# 
# p_scatter
@


<<>>=
final_raster <- function(dat) {
  
  rast_final <- rast.all@layers[[1]]
  dat <- dat[order(dat$ID), ]
  final_vector <- as.vector(dat$rasterValue)
  rast_final <- setValues(rast_final, final_vector)
  
  return(rast_final)
}

SISmm <- setZ(stack(
  final_raster(tmp_small_irr),
  final_raster(tmp_small_irr_ws),
  final_raster(tmp_large_irr),
  final_raster(tmp_large_irr_ws),
  final_raster(tmp_small_ws)
), c(1:1))

panel_names <- c("Small-scale farmers' irrigation\n",
                 "Small-scale farmers' irrigation\n        in water scarce regions",
                 "Non small-scale farmers' irrigation\n",
                 "Non small-scale farmers' irrigation\n          in water scarce regions",
                "Small-scale farmers in water scarce regions")

names(SISmm) <- panel_names

library(colorspace)

cpal_world <- c('#333333','#292929')[1]
# catTheme <- RdBuTheme(panel.background = list(col = '#FFFFFF'))
catTheme <- rasterTheme(region = c(
  '#DFF1D0',
  '#B3E7C5',
  '#77CFBE',
  '#32AAB5',
  '#0076A1',
  '#2D3184'),
  axis.line = list(col = 'transparent'),
  layout.heights = list(strip = 2.25))

my.at <- c(0, 25, 50, 75, 100)
my.brks <- seq(0, 100, by = 10)

myColorkey <- list(at = my.brks, 
                   text = list(labels = as.character(my.at), 
                               at = my.brks),
                   labels = list(cex = .6),
                   axis.line = list(col = 'transparent'),
                   space = 'right')

# axis.line = list(col = 'transparent')

tmp_world <- tmp1 %>% mutate(rasterValue = 1)
p0 <- levelplot(ratify(final_raster(tmp_world)),
            col.regions = cpal_world, 
            att = 'ID',
            colorkey = F, 
            maxpixels = 2.5e10,
            par.settings = catTheme)

p1 <- levelplot(SISmm, 
            names.attr = panel_names,
            pretty = F,
            at = my.at,
            colorkey = myColorkey,
            par.strip.text = list(panel.rect = c(2,2,1,1), cex = .7),
            margin = F,
            att = 'ID',
            scales = list(alternating = 0,
                          draw = F),
            par.settings = catTheme)

p_maps <- p1 + as.layer(p0, under = T)
p_maps
@


<<>>=
library(gridExtra)
grid.arrange(p_maps, p_scatter, ncol = 1, heights = c(1, .25), 
             layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),
                                   c(NA,NA,NA,NA,2,2,2,2,2,2,NA,NA,NA,NA,NA)))

@



\end{document}





